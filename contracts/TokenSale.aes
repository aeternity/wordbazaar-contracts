// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

contract Token =
  stateful entrypoint mint : (address, int) => unit
  stateful entrypoint transfer_allowance : (address, address, int) => unit
  stateful entrypoint burn : (int) => unit

contract Vote =
  type vote_option = bool
  type amount = int
  type vote_state = map(vote_option, amount)

  entrypoint token : () => Token
  entrypoint final_vote_state : () => option(vote_state)
  entrypoint subject_workaround : () => (string * address)
  entrypoint close_height : () => int

contract TokenSale =

  record state =
    { token : option(Token)
    , votes : map(int, (bool * Vote))
    , spread : int
    , vote_timeout : int }

  datatype event =
    AddVote(Vote, int)

  stateful entrypoint init(vote_timeout : int) : state = { token = None, votes = {}, spread = 0, vote_timeout = vote_timeout }
  stateful entrypoint set_token(token : Token) : unit = put(state{ token = Some(token) })

  payable stateful entrypoint buy() : unit =
    get_token().mint(Call.caller, Call.value)

  stateful entrypoint sell(amount : int) : unit =
    get_token().transfer_allowance(Call.caller, Contract.address, amount)
    get_token().burn(amount)
    let half = amount / 2
    Chain.spend(Call.caller, half)
    put(state{ spread @ s = s + (amount - half) })

  stateful entrypoint add_vote(vote : Vote) =
    require(vote.token() == get_token(), "NOT_SAME_TOKEN_AS_SALE")
    let vote_seq_id = Map.size(state.votes)
    put(state{ votes[vote_seq_id] = (false, vote) })
    Chain.event(AddVote(vote, vote_seq_id))
    vote_seq_id

  stateful entrypoint apply_vote_subject(vote_seq_id : int) =
    let (applied, vote) = state.votes[vote_seq_id]
    require(!applied, "VOTE_ALREADY_APPLIED")
    require(vote.close_height() + state.vote_timeout >= Chain.block_height, "VOTE_RESULT_TIMEOUTED")
    let apply_subject = () =>
      let (subject, receiver) = vote.subject_workaround()
      if(subject == "VotePayout")
        Chain.spend(receiver, state.spread)
        put(state{ spread = 0, votes[vote_seq_id] = (true, vote) })

    switch(vote.final_vote_state())
      None => abort("VOTE_NOT_YET_FINAL")
      Some(vote_state) => if(vote_state[true] > vote_state[false]) apply_subject()

  entrypoint votes() : map(int, (bool * Vote)) = state.votes
  entrypoint spread() : int = state.spread
  entrypoint vote_timeout() : int = state.vote_timeout

  entrypoint get_token() : Token =
    switch(state.token)
      Some(token) => token
      None => abort("NO_TOKEN_SET")
